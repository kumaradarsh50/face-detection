{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport _slicedToArray from '@babel/runtime/helpers/slicedToArray';\nimport React, { useRef, useMemo, useState, useEffect } from 'react';\nimport { useThree, useRender, Canvas } from 'react-three-fiber';\nimport merge from 'lodash.merge';\nimport { ShaderMaterial, AdditiveBlending, BufferGeometry, BufferAttribute, Vector3 } from 'three';\nimport OrbitControls from 'three-orbitcontrols';\nimport hexRgb from 'hex-rgb';\nimport isHex from 'is-hexcolor';\n/* eslint-disable no-shadow */\n\n/* eslint-disable no-plusplus */\n\n/* eslint-disable no-continue */\n\n/* eslint-disable no-param-reassign */\n\n/**\n * Calculate new velocity/position of current particle if it hits x, y, or z boundary\n *\n * Controlled by boundaryType, either 'bounce' or 'passthru'\n */\n\nvar handleBoundary = function handleBoundary(_ref) {\n  var bounds = _ref.bounds,\n      boundaryType = _ref.boundaryType,\n      particlePositions = _ref.particlePositions,\n      particleData = _ref.particleData,\n      i = _ref.i; // Get the boundary points of the canvas\n  // Useful for knowing when a particle is at the edge of the canvas\n\n  var xBounds = bounds.xBounds,\n      yBounds = bounds.yBounds,\n      zBounds = bounds.zBounds; // Make the current particle \"transport\" from one side of boundary to the other\n  // The particles feel like they 'disappear' and new ones are 'appearing'\n\n  if (boundaryType === 'passthru') {\n    // If a particle crosses the x-axis edge, send particle to the opposite x-axis edge\n    if (particlePositions[i * 3] < -xBounds / 2) particlePositions[i * 3] = xBounds / 2;else if (particlePositions[i * 3] > xBounds / 2) particlePositions[i * 3] = -xBounds / 2; // If a particle crosses the y-axis edge, send particle to the opposite y-axis edge\n\n    if (particlePositions[i * 3 + 1] < -yBounds / 2) particlePositions[i * 3 + 1] = yBounds / 2;else if (particlePositions[i * 3 + 1] > yBounds / 2) particlePositions[i * 3 + 1] = -yBounds / 2; // If a particle crosses the y-axis edge, send particle to the opposite y-axis edge\n\n    if (particlePositions[i * 3 + 2] < -zBounds / 2) particlePositions[i * 3 + 2] = zBounds / 2;else if (particlePositions[i * 3 + 2] > zBounds / 2) particlePositions[i * 3 + 2] = -zBounds / 2;\n  } else if (boundaryType === 'bounce') {\n    // Make the current particle \"bounce\" off of the \"bounds\" of the canvas\n    // The particles behave like balls thrown at a wall\n    if (particlePositions[i * 3] < -xBounds / 2 || particlePositions[i * 3] > xBounds / 2) particleData.velocity.x = -particleData.velocity.x;\n    if (particlePositions[i * 3 + 1] < -yBounds / 2 || particlePositions[i * 3 + 1] > yBounds / 2) particleData.velocity.y = -particleData.velocity.y;\n    if (particlePositions[i * 3 + 2] < -zBounds / 2 || particlePositions[i * 3 + 2] > zBounds / 2) particleData.velocity.z = -particleData.velocity.z;\n  }\n};\n/**\n * Animates an array of particles and lines over a three dimensional space\n *\n * This function is meant to be called from the useRender render loop -- ran on each frame\n */\n\n\nvar animate = function animate(_ref2) {\n  var minDistance = _ref2.minDistance,\n      limitConnections = _ref2.limitConnections,\n      maxConnections = _ref2.maxConnections,\n      particleCount = _ref2.particleCount,\n      lineMeshGeometry = _ref2.lineMeshGeometry,\n      pointCloudGeometry = _ref2.pointCloudGeometry,\n      particlesData = _ref2.particlesData,\n      particlePositions = _ref2.particlePositions,\n      linePositions = _ref2.linePositions,\n      lineColors = _ref2.lineColors,\n      bounds = _ref2.bounds,\n      showLines = _ref2.showLines,\n      boundaryType = _ref2.boundaryType;\n  var vertexpos = 0;\n  var colorpos = 0;\n  var numConnected = 0; // Start by assuming no line connections between particles\n\n  for (var i = 0; i < particleCount; i += 1) {\n    particlesData[i].numConnections = 0;\n  } // Update the [x, y, z] position of each particle\n\n\n  for (var _i = 0; _i < particleCount; _i += 1) {\n    // The current particle\n    var particleData = particlesData[_i];\n    particlePositions[_i * 3] += particleData.velocity.x;\n    particlePositions[_i * 3 + 1] += particleData.velocity.y;\n    particlePositions[_i * 3 + 2] += particleData.velocity.z; // Calculate new velocity/position of current particle if it hits x, y, or z boundary\n    // Controlled by boundaryType, either 'bounce' or 'passthru'\n\n    handleBoundary({\n      bounds: bounds,\n      boundaryType: boundaryType,\n      particlePositions: particlePositions,\n      particleData: particleData,\n      i: _i\n    }); // Skip to next particle if we are intentionally not drawing lines\n\n    if (!showLines || limitConnections && particleData.numConnections >= maxConnections) continue; // Calculate the distance between particles to find nearest-neighbors\n    // If particles fall within the threshold, draw a line connecting them\n\n    for (var j = _i + 1; j < particleCount; j += 1) {\n      // The \"other\" particle to compare to \"this\" one\n      var particleDataB = particlesData[j]; // Skip to next particle(don't draw more lines) if some limiting factor has been met\n\n      if (limitConnections && particleDataB.numConnections >= maxConnections) continue; // Calculate the distance between \"this\" particle and the \"other\" particle\n\n      var dx = particlePositions[_i * 3] - particlePositions[j * 3];\n      var dy = particlePositions[_i * 3 + 1] - particlePositions[j * 3 + 1];\n      var dz = particlePositions[_i * 3 + 2] - particlePositions[j * 3 + 2];\n      var dist = Math.sqrt(dx * dx + dy * dy + dz * dz); // If \"this\" particle is close enough to the \"other\" particle, draw a line connecting the two\n\n      if (dist < minDistance) {\n        // Increment the number of connections by one on both particles\n        particleData.numConnections += 1;\n        particleDataB.numConnections += 1; // The lines become more transparent the further apart the particles become\n        // The line fragment shader applies this alpha attribute when coloring the lines\n\n        var alpha = 1.0 - dist / minDistance; // Set the line position's [x, y, z] position at \"this\" point and the \"other\" point\n\n        linePositions[vertexpos++] = particlePositions[_i * 3];\n        linePositions[vertexpos++] = particlePositions[_i * 3 + 1];\n        linePositions[vertexpos++] = particlePositions[_i * 3 + 2];\n        linePositions[vertexpos++] = particlePositions[j * 3];\n        linePositions[vertexpos++] = particlePositions[j * 3 + 1];\n        linePositions[vertexpos++] = particlePositions[j * 3 + 2];\n        lineColors[colorpos++] = alpha;\n        lineColors[colorpos++] = alpha;\n        lineColors[colorpos++] = alpha;\n        lineColors[colorpos++] = alpha;\n        lineColors[colorpos++] = alpha;\n        lineColors[colorpos++] = alpha;\n        numConnected += 1;\n      }\n    }\n  } // Signal to Three.js that the line and point geometry have changed\n\n\n  lineMeshGeometry.setDrawRange(0, numConnected * 2);\n  lineMeshGeometry.attributes.position.needsUpdate = true;\n  lineMeshGeometry.attributes.color.needsUpdate = true;\n  pointCloudGeometry.attributes.position.needsUpdate = true;\n};\n/**\n * Converts a hex color to gl_FragColor format\n *\n * @param {string} color A hex color\n */\n\n\nvar genColorFromHex = function genColorFromHex(_ref) {\n  var color = _ref.color;\n  if (!isHex(color)) return \"1, 1, 1\";\n\n  var _hexRgb = hexRgb(color),\n      red = _hexRgb.red,\n      green = _hexRgb.green,\n      blue = _hexRgb.blue;\n\n  return \"\".concat((red / 255).toFixed(2), \", \").concat((green / 255).toFixed(2), \", \").concat((blue / 255).toFixed(2));\n};\n/**\n * Line shader color for solid colors option\n *\n * @param {string} color A hex color\n */\n\n\nvar solidLineColors = function solidLineColors(_ref2) {\n  var color = _ref2.color;\n  return \"\\n  vColor = vec3(\".concat(genColorFromHex({\n    color: color\n  }), \");\\n\");\n};\n/**\n * Line shader color for rainbow colors option\n */\n\n\nvar rainbowLineColors = \"\\n  vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\\n  vColor = normalize( abs( worldPosition.xyz ) );\\n\";\n/**\n * Generates a vertex shader for a connecting line in a particle system\n *\n * This shader uses the position of particles to determine their color\n * and change them as they move\n */\n\nvar getLineVertexShader = function getLineVertexShader(_ref3) {\n  var colorMode = _ref3.colorMode,\n      color = _ref3.color;\n  return \"\\n// Amount of transparency for line, calculated in Animate\\nattribute float color;\\n\\n// Calculate color based on line position\\nvarying vec3 vColor;\\nvarying float alpha;\\n\\nvoid main() {\\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n  gl_Position = projectionMatrix * mvPosition;\\n\\n  \".concat(colorMode === 'rainbow' ? rainbowLineColors : '', \"\\n  \").concat(colorMode === 'solid' ? solidLineColors({\n    color: color\n  }) : '', \"\\n  alpha = color;\\n}\\n\");\n};\n/**\n * Applies a color to a connecting line in a particle system\n */\n\n\nvar getLineFragmentShader = function getLineFragmentShader(_ref4) {\n  var transparency = _ref4.transparency;\n  return \"\\n// Color calculated from vertex shader, based on line position\\nvarying vec3 vColor;\\n// Amount of transparency from vertex shader, based on distance between particles\\nvarying float alpha;\\n\\nvoid main() {\\n  gl_FragColor = vec4( vColor, alpha * \".concat(transparency, \");\\n}\\n\");\n};\n\nvar computeLines = function (_ref) {\n  var particles = _ref.particles,\n      lines = _ref.lines;\n  var count = particles.count;\n  var color = lines.color,\n      colorMode = lines.colorMode,\n      transparency = lines.transparency,\n      visible = lines.visible; // Line material\n\n  var lineMeshMaterial = new ShaderMaterial({\n    vertexShader: getLineVertexShader({\n      colorMode: colorMode,\n      color: color\n    }),\n    fragmentShader: getLineFragmentShader({\n      transparency: transparency\n    }),\n    transparent: true,\n    blending: AdditiveBlending,\n    visible: visible\n  }); // Line mesh geometry\n\n  var lineMeshGeometry = new BufferGeometry();\n  var segments = count * count;\n  var positions = new Float32Array(segments * 3);\n  var colors = new Float32Array(segments * 3);\n  lineMeshGeometry.addAttribute('position', new BufferAttribute(positions, 3).setDynamic(true));\n  lineMeshGeometry.addAttribute('color', new BufferAttribute(colors, 3).setDynamic(true));\n  lineMeshGeometry.computeBoundingSphere();\n  lineMeshGeometry.setDrawRange(0, 0);\n  return [lineMeshGeometry, lineMeshMaterial, positions, colors];\n};\n/**\n * Converts a hex color to gl_FragColor format\n *\n * @param {string} color A hex color\n */\n\n\nvar genColorFromHex$1 = function genColorFromHex(_ref) {\n  var color = _ref.color;\n  if (!isHex(color)) return \"1, 1, 1\";\n\n  var _hexRgb = hexRgb(color),\n      red = _hexRgb.red,\n      green = _hexRgb.green,\n      blue = _hexRgb.blue;\n\n  return \"\".concat((red / 255).toFixed(2), \", \").concat((green / 255).toFixed(2), \", \").concat((blue / 255).toFixed(2));\n};\n/**\n * Vertex shader color for solid colors option\n *\n * @param {string} color A hex color\n */\n\n\nvar solidVertexColors = function solidVertexColors(_ref2) {\n  var color = _ref2.color;\n  return \"\\n  vColor = vec3(\".concat(genColorFromHex$1({\n    color: color\n  }), \");\\n\");\n};\n/**\n * Vertex shader color for rainbow colors option\n */\n\n\nvar rainbowVertextColors = \"\\n  vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\\n  vColor = vec3( normalize( abs( worldPosition.xyz ) ));\\n\";\n/**\n * Generates a vertex shader for a particle system\n *\n * This shader uses the position of particles to determine their color\n * and change them as they move\n */\n\nvar getParticleVertexShader = function getParticleVertexShader(_ref3) {\n  var colorMode = _ref3.colorMode,\n      color = _ref3.color,\n      devicePixelRatio = _ref3.devicePixelRatio;\n  return \"\\n// Size attribute for particle geometry\\nattribute float size;\\n\\n// Calculate color based on particle position\\nvarying vec3 vColor;\\n\\nvoid main() {\\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n  gl_PointSize = size * ( 300.0 / -mvPosition.z ) * \".concat(devicePixelRatio, \";\\n  gl_Position = projectionMatrix * mvPosition;\\n\\n  \").concat(colorMode === 'rainbow' ? rainbowVertextColors : '', \"\\n  \").concat(colorMode === 'solid' ? solidVertexColors({\n    color: color\n  }) : '', \"\\n}\\n\");\n}; // \"Cuts\" a circle out of the default square shape\n// by setting the \"leftovers\" as transparent\n\n\nvar circleParticleShape = \"\\nfloat r = 0.0, delta = 0.0, alpha = 1.0;\\nvec2 cxy = 2.0 * gl_PointCoord - 1.0;\\nr = dot(cxy, cxy);\\nif (r > 1.0) {\\n    discard;\\n}\\n\";\n/**\n * Applies a shape to each particle\n *\n * @param {String} particleShape Either 'circle' or 'square'\n * @param {Number} transparency The alpha channel rgba value for particles\n */\n\nvar getParticleFragmentShader = function getParticleFragmentShader(_ref4) {\n  var particleShape = _ref4.particleShape,\n      transparency = _ref4.transparency;\n  return \"\\n// Color from uniforms arg\\nuniform vec3 color;\\n\\n// Color calculated from vertex shader, based on particle position\\nvarying vec3 vColor;\\n\\nvoid main() {\\n  \".concat(particleShape === 'circle' ? circleParticleShape : '', \"\\n  gl_FragColor = vec4(vColor, \").concat(transparency, \");\\n}\\n\");\n};\n\nvar computeParticles = function (_ref) {\n  var particles = _ref.particles,\n      dimension = _ref.dimension,\n      devicePixelRatio = _ref.devicePixelRatio,\n      direction = _ref.direction,\n      size = _ref.size,\n      r = _ref.r,\n      velocity = _ref.velocity;\n  var boundingBox = particles.boundingBox,\n      count = particles.count,\n      colorMode = particles.colorMode,\n      color = particles.color,\n      shape = particles.shape,\n      transparency = particles.transparency,\n      minSize = particles.minSize,\n      maxSize = particles.maxSize,\n      visible = particles.visible; // Add particles to geometry\n  // Maintain two arrays\n  // particlePositions contains random x,y,z coords for each particle\n  // particlesData contains a random x,y,z velocity vector for each particle\n\n  var pointCloudGeometry = new BufferGeometry();\n  var particlePositions = new Float32Array(count * 3);\n  var particleSizes = new Float32Array(count);\n  var particlesData = [];\n  var xBounds;\n  var yBounds;\n  var zBounds;\n\n  if (boundingBox === 'canvas') {\n    // Adjust size of particle field contstraints based on\n    // whether field is 2D or 3D\n    xBounds = dimension === '2D' ? size.width : size.width;\n    yBounds = dimension === '2D' ? size.height : size.height * 1.5;\n    zBounds = dimension === '2D' ? 0 : size.width;\n  }\n\n  if (boundingBox === 'cube') {\n    xBounds = r;\n    yBounds = r;\n    zBounds = dimension === '2D' ? 0 : r;\n  }\n\n  for (var i = 0; i < count; i += 1) {\n    // Calculate possible (x, y, z) location of particle\n    // within the size of the canvas or cube size\n    var x = Math.random() * xBounds - xBounds / 2;\n    var y = Math.random() * yBounds - yBounds / 2;\n    var z = Math.random() * zBounds - zBounds / 2;\n    particlePositions[i * 3] = x;\n    particlePositions[i * 3 + 1] = y;\n    particlePositions[i * 3 + 2] = z; // Choose size of each particle\n\n    particleSizes[i] = Math.random() * (maxSize - minSize) + minSize; // Calculates a random number between given range\n\n    var getVelocityMultiplier = function getVelocityMultiplier(min, max) {\n      return Math.random() * (max - min) + min;\n    };\n\n    var xMin = direction.xMin,\n        xMax = direction.xMax,\n        yMin = direction.yMin,\n        yMax = direction.yMax,\n        zMin = direction.zMin,\n        zMax = direction.zMax;\n    particlesData.push({\n      velocity: new Vector3(getVelocityMultiplier(xMin, xMax) * velocity, getVelocityMultiplier(yMin, yMax) * velocity, getVelocityMultiplier(zMin, zMax) * velocity),\n      numConnections: 0\n    });\n  }\n\n  pointCloudGeometry.setDrawRange(0, count);\n  pointCloudGeometry.addAttribute('position', new BufferAttribute(particlePositions, 3).setDynamic(true));\n  pointCloudGeometry.addAttribute('size', new BufferAttribute(particleSizes, 1).setDynamic(true)); // Material for particle, use shaders to morph shape and color\n\n  var pointMaterial = new ShaderMaterial({\n    vertexShader: getParticleVertexShader({\n      colorMode: colorMode,\n      color: color,\n      devicePixelRatio: devicePixelRatio\n    }),\n    fragmentShader: getParticleFragmentShader({\n      particleShape: shape,\n      transparency: transparency\n    }),\n    transparent: transparency < 1,\n    blending: AdditiveBlending,\n    visible: visible\n  }); // The x,y,z bounds of possible particle positions\n  // needed for Animate function\n\n  var bounds = {\n    xBounds: xBounds,\n    yBounds: yBounds,\n    zBounds: zBounds\n  };\n  return [pointCloudGeometry, pointMaterial, particlesData, particlePositions, bounds];\n};\n\nvar r = 400;\n/**\n * Creates a particle cloud with various config options\n */\n\nvar ParticleField = function ParticleField(_ref) {\n  var particles = _ref.particles,\n      lines = _ref.lines,\n      direction = _ref.direction,\n      showCube = _ref.showCube,\n      cameraControls = _ref.cameraControls,\n      dimension = _ref.dimension,\n      velocity = _ref.velocity,\n      boundaryType = _ref.boundaryType;\n  var controlsRef = useRef(0);\n  var animation = useRef(0);\n  var group = useRef();\n\n  var _useThree = useThree(),\n      gl = _useThree.gl,\n      canvas = _useThree.canvas,\n      camera = _useThree.camera,\n      size = _useThree.size; // Scale rendering automatically to window DPI\n  // Pass this value to fragment shaders: gl_PointSize needs to scale against this value\n  // https://threejs.org/docs/#api/en/renderers/WebGLRenderer.setPixelRatio\n\n\n  var devicePixelRatio = window.devicePixelRatio.toFixed(1);\n  gl.setPixelRatio(devicePixelRatio); // Default distance from camera to particle field\n\n  var distToParticles = 1750; // Setup camera\n\n  controlsRef.current = useMemo(function () {\n    var aspectRatio = size.width / size.height; // Calculates the proper FOV for 2D particle field to\n    // perfectly fill canvas\n\n    var cameraFOV = 2 * Math.atan(size.width / aspectRatio / (2 * distToParticles)) * (180 / Math.PI);\n    camera.fov = cameraFOV;\n    camera.aspect = aspectRatio;\n    camera.near = 1; // Allow field to stay in view while zooming really far out\n\n    camera.far = 10000; // Remove event listeners from previous controls if they exist\n    // Set initial camera position if controls haven't taken over yet\n\n    if (controlsRef.current) controlsRef.current.dispose();else camera.position.set(0, 0, distToParticles); // Setup movement controls for mouse/touch to manipulate camera position\n    // https://threejs.org/docs/#examples/controls/OrbitControls\n\n    var controls = new OrbitControls(camera, canvas); // Apply given settings to camera controls\n\n    Object.entries(cameraControls).forEach(function (_ref2) {\n      var _ref3 = _slicedToArray(_ref2, 2),\n          key = _ref3[0],\n          value = _ref3[1];\n\n      controls[key] = value;\n    });\n    return controls;\n  }, [camera, cameraControls, canvas, size.height, size.width]); // When the resetCameraFlag option is toggled to 'true', reset camera position\n\n  if (cameraControls.resetCameraFlag === true) {\n    camera.position.set(0, 0, 1750);\n  } // Compute lines between points\n\n\n  var _useMemo = useMemo(function () {\n    return computeLines({\n      particles: particles,\n      lines: lines\n    });\n  }, [particles, lines]),\n      _useMemo2 = _slicedToArray(_useMemo, 4),\n      lineMeshGeometry = _useMemo2[0],\n      lineMeshMaterial = _useMemo2[1],\n      linePositions = _useMemo2[2],\n      lineColors = _useMemo2[3]; // Compute point cloud\n\n\n  var _useMemo3 = useMemo(function () {\n    return computeParticles({\n      particles: particles,\n      dimension: dimension,\n      devicePixelRatio: devicePixelRatio,\n      direction: direction,\n      size: size,\n      r: r,\n      velocity: velocity\n    });\n  }, [particles, dimension, direction, devicePixelRatio, size, velocity]),\n      _useMemo4 = _slicedToArray(_useMemo3, 5),\n      pointCloudGeometry = _useMemo4[0],\n      pointMaterial = _useMemo4[1],\n      particlesData = _useMemo4[2],\n      particlePositions = _useMemo4[3],\n      bounds = _useMemo4[4]; // Assign state to animation ref\n  // This object is passed to Animation.js in render loop\n\n\n  animation.current = {\n    minDistance: lines.minDistance,\n    limitConnections: lines.limitConnections,\n    maxConnections: lines.maxConnections,\n    particleCount: particles.count,\n    bounds: bounds,\n    lineMeshGeometry: lineMeshGeometry,\n    pointCloudGeometry: pointCloudGeometry,\n    particlesData: particlesData,\n    particlePositions: particlePositions,\n    linePositions: linePositions,\n    lineColors: lineColors,\n    showLines: lines.visible,\n    boundaryType: boundaryType\n  }; // Direct access to render loop, executes on each frame\n  // State changes must be passed into hook via refs\n  // useRender() contents are called in a requestAnimationFrame()\n\n  useRender(function () {\n    // Enables damping of OrbitControls\n    controlsRef.current.update(); // Animate current state of particles + lines\n\n    animate(animation.current);\n  });\n  return React.createElement(\"scene\", null, React.createElement(\"group\", {\n    ref: group\n  }, showCube && React.createElement(\"boxHelper\", null, React.createElement(\"mesh\", {\n    name: \"object\"\n  }, React.createElement(\"meshBasicMaterial\", {\n    attach: \"material\",\n    color: \"white\",\n    blending: AdditiveBlending,\n    wireframe: true,\n    transparent: true\n  }), React.createElement(\"boxBufferGeometry\", {\n    attach: \"geometry\",\n    args: [r, r, r]\n  }))), lines.visible && React.createElement(\"lineSegments\", {\n    geometry: lineMeshGeometry,\n    material: lineMeshMaterial\n  }), particles.visible && React.createElement(\"points\", {\n    geometry: pointCloudGeometry,\n    material: pointMaterial\n  })));\n};\n/**\n * The default configuation for the ParticleField component\n *\n * Any option passed in via props will overwrite the default config\n */\n\n\nvar initialConfig = {\n  showCube: true,\n  dimension: '3D',\n  velocity: 2,\n  boundaryType: 'bounce',\n  antialias: false,\n  direction: {\n    xMin: -1,\n    xMax: 1,\n    yMin: -1,\n    yMax: 1,\n    zMin: -1,\n    zMax: 1\n  },\n  lines: {\n    colorMode: 'rainbow',\n    color: '#351CCB',\n    transparency: 0.9,\n    limitConnections: true,\n    maxConnections: 20,\n    minDistance: 150,\n    visible: true\n  },\n  particles: {\n    colorMode: 'rainbow',\n    color: '#3FB568',\n    transparency: 0.9,\n    shape: 'square',\n    boundingBox: 'canvas',\n    count: 500,\n    minSize: 10,\n    maxSize: 75,\n    visible: true\n  },\n  cameraControls: {\n    enabled: true,\n    enableDamping: true,\n    dampingFactor: 0.2,\n    enableZoom: true,\n    autoRotate: true,\n    autoRotateSpeed: 0.3,\n    resetCameraFlag: false\n  }\n};\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n/**\n * Creates a 2D/3D particle field with react-three-fiber, three.js and WebGL\n *\n * Documentation on the configuration object can be found in the github repo\n * @see https://github.com/tim-soft/react-particles-webgl\n *\n * For a real-time configuration generator and various demos\n * @see https://timellenberger.com/particles\n */\n\n\nvar ParticleCanvas = function ParticleCanvas(_ref) {\n  var config = _ref.config;\n\n  var _useState = useState(false),\n      _useState2 = _slicedToArray(_useState, 2),\n      clientSide = _useState2[0],\n      setClientSide = _useState2[1];\n\n  useEffect(function () {\n    setClientSide(true);\n  }, []);\n  if (!clientSide) return null;\n  return React.createElement(Canvas, {\n    gl: {\n      antialias: Object.prototype.hasOwnProperty.call(config, 'antialias') ? config.antialias : initialConfig.antialias\n    }\n  }, React.createElement(ParticleField, merge({}, initialConfig, config)));\n};\n\nParticleCanvas.defaultProps = {\n  config: {}\n};\n\nvar defaultConfig = _objectSpread({}, initialConfig);\n\nexport default ParticleCanvas;\nexport { defaultConfig };","map":{"version":3,"sources":["../src/lib/animate.js","../src/shaders/LineShaders.js","../src/lib/computeLines.js","../src/shaders/ParticleShaders.js","../src/lib/computeParticles.js","../src/ParticleField.js","../src/config.js","../src/index.js"],"names":["handleBoundary","bounds","boundaryType","particlePositions","particleData","i","xBounds","yBounds","zBounds","animate","minDistance","limitConnections","maxConnections","particleCount","lineMeshGeometry","pointCloudGeometry","particlesData","linePositions","lineColors","showLines","vertexpos","colorpos","numConnected","j","particleDataB","dx","dy","dz","dist","Math","alpha","genColorFromHex","color","isHex","red","green","blue","hexRgb","solidLineColors","rainbowLineColors","getLineVertexShader","colorMode","getLineFragmentShader","transparency","particles","lines","count","visible","lineMeshMaterial","vertexShader","fragmentShader","transparent","blending","segments","positions","colors","solidVertexColors","rainbowVertextColors","getParticleVertexShader","devicePixelRatio","circleParticleShape","getParticleFragmentShader","particleShape","dimension","direction","size","r","velocity","boundingBox","shape","minSize","maxSize","particleSizes","x","y","z","getVelocityMultiplier","max","xMin","xMax","yMin","yMax","zMin","zMax","numConnections","pointMaterial","ParticleField","showCube","cameraControls","controlsRef","useRef","animation","group","gl","canvas","camera","useThree","window","distToParticles","useMemo","aspectRatio","cameraFOV","controls","Object","key","value","computeLines","computeParticles","useRender","antialias","enabled","enableDamping","dampingFactor","enableZoom","autoRotate","autoRotateSpeed","resetCameraFlag","ParticleCanvas","config","clientSide","setClientSide","useState","useEffect","initialConfig","merge","defaultConfig"],"mappings":"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","sourcesContent":["/* eslint-disable no-shadow */\n/* eslint-disable no-plusplus */\n/* eslint-disable no-continue */\n/* eslint-disable no-param-reassign */\n\n/**\n * Calculate new velocity/position of current particle if it hits x, y, or z boundary\n *\n * Controlled by boundaryType, either 'bounce' or 'passthru'\n */\nconst handleBoundary = ({\n  /* The boundaries of the particle field */\n  bounds,\n  /* Either 'bounce' or 'passthru' */\n  boundaryType,\n  /* The x, y, z positions of current particle */\n  particlePositions,\n  /* The x, y, z velocities of current particle */\n  particleData,\n  i\n}) => {\n  // Get the boundary points of the canvas\n  // Useful for knowing when a particle is at the edge of the canvas\n  const { xBounds, yBounds, zBounds } = bounds;\n\n  // Make the current particle \"transport\" from one side of boundary to the other\n  // The particles feel like they 'disappear' and new ones are 'appearing'\n  if (boundaryType === 'passthru') {\n    // If a particle crosses the x-axis edge, send particle to the opposite x-axis edge\n    if (particlePositions[i * 3] < -xBounds / 2)\n      particlePositions[i * 3] = xBounds / 2;\n    else if (particlePositions[i * 3] > xBounds / 2)\n      particlePositions[i * 3] = -xBounds / 2;\n\n    // If a particle crosses the y-axis edge, send particle to the opposite y-axis edge\n    if (particlePositions[i * 3 + 1] < -yBounds / 2)\n      particlePositions[i * 3 + 1] = yBounds / 2;\n    else if (particlePositions[i * 3 + 1] > yBounds / 2)\n      particlePositions[i * 3 + 1] = -yBounds / 2;\n\n    // If a particle crosses the y-axis edge, send particle to the opposite y-axis edge\n    if (particlePositions[i * 3 + 2] < -zBounds / 2)\n      particlePositions[i * 3 + 2] = zBounds / 2;\n    else if (particlePositions[i * 3 + 2] > zBounds / 2)\n      particlePositions[i * 3 + 2] = -zBounds / 2;\n  } else if (boundaryType === 'bounce') {\n    // Make the current particle \"bounce\" off of the \"bounds\" of the canvas\n    // The particles behave like balls thrown at a wall\n    if (\n      particlePositions[i * 3] < -xBounds / 2 ||\n      particlePositions[i * 3] > xBounds / 2\n    )\n      particleData.velocity.x = -particleData.velocity.x;\n    if (\n      particlePositions[i * 3 + 1] < -yBounds / 2 ||\n      particlePositions[i * 3 + 1] > yBounds / 2\n    )\n      particleData.velocity.y = -particleData.velocity.y;\n    if (\n      particlePositions[i * 3 + 2] < -zBounds / 2 ||\n      particlePositions[i * 3 + 2] > zBounds / 2\n    )\n      particleData.velocity.z = -particleData.velocity.z;\n  }\n};\n\n/**\n * Animates an array of particles and lines over a three dimensional space\n *\n * This function is meant to be called from the useRender render loop -- ran on each frame\n */\nconst animate = ({\n  minDistance,\n  limitConnections,\n  maxConnections,\n  particleCount,\n  lineMeshGeometry,\n  pointCloudGeometry,\n  particlesData,\n  particlePositions,\n  linePositions,\n  lineColors,\n  bounds,\n  showLines,\n  boundaryType\n}) => {\n  let vertexpos = 0;\n  let colorpos = 0;\n  let numConnected = 0;\n\n  // Start by assuming no line connections between particles\n  for (let i = 0; i < particleCount; i += 1)\n    particlesData[i].numConnections = 0;\n\n  // Update the [x, y, z] position of each particle\n  for (let i = 0; i < particleCount; i += 1) {\n    // The current particle\n    const particleData = particlesData[i];\n    particlePositions[i * 3] += particleData.velocity.x;\n    particlePositions[i * 3 + 1] += particleData.velocity.y;\n    particlePositions[i * 3 + 2] += particleData.velocity.z;\n\n    // Calculate new velocity/position of current particle if it hits x, y, or z boundary\n    // Controlled by boundaryType, either 'bounce' or 'passthru'\n    handleBoundary({\n      bounds,\n      boundaryType,\n      particlePositions,\n      particleData,\n      i\n    });\n\n    // Skip to next particle if we are intentionally not drawing lines\n    if (\n      !showLines ||\n      (limitConnections && particleData.numConnections >= maxConnections)\n    )\n      continue;\n\n    // Calculate the distance between particles to find nearest-neighbors\n    // If particles fall within the threshold, draw a line connecting them\n    for (let j = i + 1; j < particleCount; j += 1) {\n      // The \"other\" particle to compare to \"this\" one\n      const particleDataB = particlesData[j];\n\n      // Skip to next particle(don't draw more lines) if some limiting factor has been met\n      if (limitConnections && particleDataB.numConnections >= maxConnections)\n        continue;\n\n      // Calculate the distance between \"this\" particle and the \"other\" particle\n      const dx = particlePositions[i * 3] - particlePositions[j * 3];\n      const dy = particlePositions[i * 3 + 1] - particlePositions[j * 3 + 1];\n      const dz = particlePositions[i * 3 + 2] - particlePositions[j * 3 + 2];\n      const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);\n\n      // If \"this\" particle is close enough to the \"other\" particle, draw a line connecting the two\n      if (dist < minDistance) {\n        // Increment the number of connections by one on both particles\n        particleData.numConnections += 1;\n        particleDataB.numConnections += 1;\n\n        // The lines become more transparent the further apart the particles become\n        // The line fragment shader applies this alpha attribute when coloring the lines\n        const alpha = 1.0 - dist / minDistance;\n\n        // Set the line position's [x, y, z] position at \"this\" point and the \"other\" point\n        linePositions[vertexpos++] = particlePositions[i * 3];\n        linePositions[vertexpos++] = particlePositions[i * 3 + 1];\n        linePositions[vertexpos++] = particlePositions[i * 3 + 2];\n        linePositions[vertexpos++] = particlePositions[j * 3];\n        linePositions[vertexpos++] = particlePositions[j * 3 + 1];\n        linePositions[vertexpos++] = particlePositions[j * 3 + 2];\n        lineColors[colorpos++] = alpha;\n        lineColors[colorpos++] = alpha;\n        lineColors[colorpos++] = alpha;\n        lineColors[colorpos++] = alpha;\n        lineColors[colorpos++] = alpha;\n        lineColors[colorpos++] = alpha;\n        numConnected += 1;\n      }\n    }\n  }\n\n  // Signal to Three.js that the line and point geometry have changed\n  lineMeshGeometry.setDrawRange(0, numConnected * 2);\n  lineMeshGeometry.attributes.position.needsUpdate = true;\n  lineMeshGeometry.attributes.color.needsUpdate = true;\n  pointCloudGeometry.attributes.position.needsUpdate = true;\n};\n\nexport default animate;\n","import hexRgb from 'hex-rgb';\nimport isHex from 'is-hexcolor';\n\n/**\n * Converts a hex color to gl_FragColor format\n *\n * @param {string} color A hex color\n */\nconst genColorFromHex = ({ color }) => {\n  if (!isHex(color)) return `1, 1, 1`;\n\n  const { red, green, blue } = hexRgb(color);\n  return `${(red / 255).toFixed(2)}, ${(green / 255).toFixed(2)}, ${(\n    blue / 255\n  ).toFixed(2)}`;\n};\n\n/**\n * Line shader color for solid colors option\n *\n * @param {string} color A hex color\n */\nconst solidLineColors = ({ color }) => `\n  vColor = vec3(${genColorFromHex({ color })});\n`;\n\n/**\n * Line shader color for rainbow colors option\n */\nconst rainbowLineColors = `\n  vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n  vColor = normalize( abs( worldPosition.xyz ) );\n`;\n\n/**\n * Generates a vertex shader for a connecting line in a particle system\n *\n * This shader uses the position of particles to determine their color\n * and change them as they move\n */\nexport const getLineVertexShader = ({ colorMode, color }) => `\n// Amount of transparency for line, calculated in Animate\nattribute float color;\n\n// Calculate color based on line position\nvarying vec3 vColor;\nvarying float alpha;\n\nvoid main() {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  gl_Position = projectionMatrix * mvPosition;\n\n  ${colorMode === 'rainbow' ? rainbowLineColors : ''}\n  ${colorMode === 'solid' ? solidLineColors({ color }) : ''}\n  alpha = color;\n}\n`;\n\n/**\n * Applies a color to a connecting line in a particle system\n */\nexport const getLineFragmentShader = ({ transparency }) => `\n// Color calculated from vertex shader, based on line position\nvarying vec3 vColor;\n// Amount of transparency from vertex shader, based on distance between particles\nvarying float alpha;\n\nvoid main() {\n  gl_FragColor = vec4( vColor, alpha * ${transparency});\n}\n`;\n","import {\n  AdditiveBlending,\n  BufferAttribute,\n  BufferGeometry,\n  ShaderMaterial\n} from 'three';\nimport {\n  getLineVertexShader,\n  getLineFragmentShader\n} from '../shaders/LineShaders';\n\nexport default ({ particles, lines }) => {\n  const { count } = particles;\n  const { color, colorMode, transparency, visible } = lines;\n\n  // Line material\n  const lineMeshMaterial = new ShaderMaterial({\n    vertexShader: getLineVertexShader({ colorMode, color }),\n    fragmentShader: getLineFragmentShader({ transparency }),\n    transparent: true,\n    blending: AdditiveBlending,\n    visible\n  });\n\n  // Line mesh geometry\n  const lineMeshGeometry = new BufferGeometry();\n  const segments = count * count;\n  const positions = new Float32Array(segments * 3);\n  const colors = new Float32Array(segments * 3);\n\n  lineMeshGeometry.addAttribute(\n    'position',\n    new BufferAttribute(positions, 3).setDynamic(true)\n  );\n  lineMeshGeometry.addAttribute(\n    'color',\n    new BufferAttribute(colors, 3).setDynamic(true)\n  );\n  lineMeshGeometry.computeBoundingSphere();\n  lineMeshGeometry.setDrawRange(0, 0);\n\n  return [lineMeshGeometry, lineMeshMaterial, positions, colors];\n};\n","import hexRgb from 'hex-rgb';\nimport isHex from 'is-hexcolor';\n\n/**\n * Converts a hex color to gl_FragColor format\n *\n * @param {string} color A hex color\n */\nconst genColorFromHex = ({ color }) => {\n  if (!isHex(color)) return `1, 1, 1`;\n\n  const { red, green, blue } = hexRgb(color);\n  return `${(red / 255).toFixed(2)}, ${(green / 255).toFixed(2)}, ${(\n    blue / 255\n  ).toFixed(2)}`;\n};\n\n/**\n * Vertex shader color for solid colors option\n *\n * @param {string} color A hex color\n */\nconst solidVertexColors = ({ color }) => `\n  vColor = vec3(${genColorFromHex({ color })});\n`;\n\n/**\n * Vertex shader color for rainbow colors option\n */\nconst rainbowVertextColors = `\n  vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n  vColor = vec3( normalize( abs( worldPosition.xyz ) ));\n`;\n\n/**\n * Generates a vertex shader for a particle system\n *\n * This shader uses the position of particles to determine their color\n * and change them as they move\n */\nexport const getParticleVertexShader = ({\n  colorMode,\n  color,\n  devicePixelRatio\n}) => `\n// Size attribute for particle geometry\nattribute float size;\n\n// Calculate color based on particle position\nvarying vec3 vColor;\n\nvoid main() {\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  gl_PointSize = size * ( 300.0 / -mvPosition.z ) * ${devicePixelRatio};\n  gl_Position = projectionMatrix * mvPosition;\n\n  ${colorMode === 'rainbow' ? rainbowVertextColors : ''}\n  ${colorMode === 'solid' ? solidVertexColors({ color }) : ''}\n}\n`;\n\n// \"Cuts\" a circle out of the default square shape\n// by setting the \"leftovers\" as transparent\nconst circleParticleShape = `\nfloat r = 0.0, delta = 0.0, alpha = 1.0;\nvec2 cxy = 2.0 * gl_PointCoord - 1.0;\nr = dot(cxy, cxy);\nif (r > 1.0) {\n    discard;\n}\n`;\n\n/**\n * Applies a shape to each particle\n *\n * @param {String} particleShape Either 'circle' or 'square'\n * @param {Number} transparency The alpha channel rgba value for particles\n */\nexport const getParticleFragmentShader = ({ particleShape, transparency }) => `\n// Color from uniforms arg\nuniform vec3 color;\n\n// Color calculated from vertex shader, based on particle position\nvarying vec3 vColor;\n\nvoid main() {\n  ${particleShape === 'circle' ? circleParticleShape : ''}\n  gl_FragColor = vec4(vColor, ${transparency});\n}\n`;\n","import {\n  AdditiveBlending,\n  BufferAttribute,\n  BufferGeometry,\n  ShaderMaterial,\n  Vector3\n} from 'three';\nimport {\n  getParticleVertexShader,\n  getParticleFragmentShader\n} from '../shaders/ParticleShaders';\n\nexport default ({\n  particles,\n  dimension,\n  devicePixelRatio,\n  direction,\n  size,\n  r,\n  velocity\n}) => {\n  const {\n    boundingBox,\n    count,\n    colorMode,\n    color,\n    shape,\n    transparency,\n    minSize,\n    maxSize,\n    visible\n  } = particles;\n  // Add particles to geometry\n  // Maintain two arrays\n  // particlePositions contains random x,y,z coords for each particle\n  // particlesData contains a random x,y,z velocity vector for each particle\n  const pointCloudGeometry = new BufferGeometry();\n  const particlePositions = new Float32Array(count * 3);\n  const particleSizes = new Float32Array(count);\n  const particlesData = [];\n\n  let xBounds;\n  let yBounds;\n  let zBounds;\n  if (boundingBox === 'canvas') {\n    // Adjust size of particle field contstraints based on\n    // whether field is 2D or 3D\n    xBounds = dimension === '2D' ? size.width : size.width;\n    yBounds = dimension === '2D' ? size.height : size.height * 1.5;\n    zBounds = dimension === '2D' ? 0 : size.width;\n  }\n  if (boundingBox === 'cube') {\n    xBounds = r;\n    yBounds = r;\n    zBounds = dimension === '2D' ? 0 : r;\n  }\n\n  for (let i = 0; i < count; i += 1) {\n    // Calculate possible (x, y, z) location of particle\n    // within the size of the canvas or cube size\n    const x = Math.random() * xBounds - xBounds / 2;\n    const y = Math.random() * yBounds - yBounds / 2;\n    const z = Math.random() * zBounds - zBounds / 2;\n    particlePositions[i * 3] = x;\n    particlePositions[i * 3 + 1] = y;\n    particlePositions[i * 3 + 2] = z;\n\n    // Choose size of each particle\n    particleSizes[i] = Math.random() * (maxSize - minSize) + minSize;\n\n    // Calculates a random number between given range\n    const getVelocityMultiplier = (min, max) =>\n      Math.random() * (max - min) + min;\n\n    const { xMin, xMax, yMin, yMax, zMin, zMax } = direction;\n\n    particlesData.push({\n      velocity: new Vector3(\n        getVelocityMultiplier(xMin, xMax) * velocity,\n        getVelocityMultiplier(yMin, yMax) * velocity,\n        getVelocityMultiplier(zMin, zMax) * velocity\n      ),\n      numConnections: 0\n    });\n  }\n\n  pointCloudGeometry.setDrawRange(0, count);\n  pointCloudGeometry.addAttribute(\n    'position',\n    new BufferAttribute(particlePositions, 3).setDynamic(true)\n  );\n  pointCloudGeometry.addAttribute(\n    'size',\n    new BufferAttribute(particleSizes, 1).setDynamic(true)\n  );\n\n  // Material for particle, use shaders to morph shape and color\n  const pointMaterial = new ShaderMaterial({\n    vertexShader: getParticleVertexShader({\n      colorMode,\n      color,\n      devicePixelRatio\n    }),\n    fragmentShader: getParticleFragmentShader({\n      particleShape: shape,\n      transparency\n    }),\n    transparent: transparency < 1,\n    blending: AdditiveBlending,\n    visible\n  });\n\n  // The x,y,z bounds of possible particle positions\n  // needed for Animate function\n  const bounds = {\n    xBounds,\n    yBounds,\n    zBounds\n  };\n\n  return [\n    pointCloudGeometry,\n    pointMaterial,\n    particlesData,\n    particlePositions,\n    bounds\n  ];\n};\n","/* eslint-disable no-shadow */\nimport React, { useRef, useMemo } from 'react';\nimport PropTypes from 'prop-types';\nimport { AdditiveBlending } from 'three';\nimport { useRender, useThree } from 'react-three-fiber';\nimport OrbitControls from 'three-orbitcontrols';\nimport animate from './lib/animate';\nimport computeLines from './lib/computeLines';\nimport computeParticles from './lib/computeParticles';\n\n// Default Cube dimensions\nconst r = 400;\n\n/**\n * Creates a particle cloud with various config options\n */\nconst ParticleField = ({\n  particles,\n  lines,\n  direction,\n  showCube,\n  cameraControls,\n  dimension,\n  velocity,\n  boundaryType\n}) => {\n  const controlsRef = useRef(0);\n  const animation = useRef(0);\n  const group = useRef();\n\n  const { gl, canvas, camera, size } = useThree();\n  // Scale rendering automatically to window DPI\n  // Pass this value to fragment shaders: gl_PointSize needs to scale against this value\n  // https://threejs.org/docs/#api/en/renderers/WebGLRenderer.setPixelRatio\n  const devicePixelRatio = window.devicePixelRatio.toFixed(1);\n  gl.setPixelRatio(devicePixelRatio);\n\n  // Default distance from camera to particle field\n  const distToParticles = 1750;\n\n  // Setup camera\n  controlsRef.current = useMemo(() => {\n    const aspectRatio = size.width / size.height;\n    // Calculates the proper FOV for 2D particle field to\n    // perfectly fill canvas\n    const cameraFOV =\n      2 *\n      Math.atan(size.width / aspectRatio / (2 * distToParticles)) *\n      (180 / Math.PI);\n\n    camera.fov = cameraFOV;\n    camera.aspect = aspectRatio;\n    camera.near = 1;\n    // Allow field to stay in view while zooming really far out\n    camera.far = 10000;\n\n    // Remove event listeners from previous controls if they exist\n    // Set initial camera position if controls haven't taken over yet\n    if (controlsRef.current) controlsRef.current.dispose();\n    else camera.position.set(0, 0, distToParticles);\n\n    // Setup movement controls for mouse/touch to manipulate camera position\n    // https://threejs.org/docs/#examples/controls/OrbitControls\n    const controls = new OrbitControls(camera, canvas);\n\n    // Apply given settings to camera controls\n    Object.entries(cameraControls).forEach(([key, value]) => {\n      controls[key] = value;\n    });\n\n    return controls;\n  }, [camera, cameraControls, canvas, size.height, size.width]);\n\n  // When the resetCameraFlag option is toggled to 'true', reset camera position\n  if (cameraControls.resetCameraFlag === true) {\n    camera.position.set(0, 0, 1750);\n  }\n\n  // Compute lines between points\n  const [\n    lineMeshGeometry,\n    lineMeshMaterial,\n    linePositions,\n    lineColors\n  ] = useMemo(() => computeLines({ particles, lines }), [particles, lines]);\n\n  // Compute point cloud\n  const [\n    pointCloudGeometry,\n    pointMaterial,\n    particlesData,\n    particlePositions,\n    bounds\n  ] = useMemo(\n    () =>\n      computeParticles({\n        particles,\n        dimension,\n        devicePixelRatio,\n        direction,\n        size,\n        r,\n        velocity\n      }),\n    [particles, dimension, direction, devicePixelRatio, size, velocity]\n  );\n\n  // Assign state to animation ref\n  // This object is passed to Animation.js in render loop\n  animation.current = {\n    minDistance: lines.minDistance,\n    limitConnections: lines.limitConnections,\n    maxConnections: lines.maxConnections,\n    particleCount: particles.count,\n    bounds,\n    lineMeshGeometry,\n    pointCloudGeometry,\n    particlesData,\n    particlePositions,\n    linePositions,\n    lineColors,\n    showLines: lines.visible,\n    boundaryType\n  };\n\n  // Direct access to render loop, executes on each frame\n  // State changes must be passed into hook via refs\n  // useRender() contents are called in a requestAnimationFrame()\n  useRender(() => {\n    // Enables damping of OrbitControls\n    controlsRef.current.update();\n    // Animate current state of particles + lines\n    animate(animation.current);\n  });\n\n  return (\n    <scene>\n      <group ref={group}>\n        {/* Bounding box that particles exist inside of */}\n        {showCube && (\n          <boxHelper>\n            <mesh name=\"object\">\n              <meshBasicMaterial\n                attach=\"material\"\n                color=\"white\"\n                blending={AdditiveBlending}\n                wireframe\n                transparent\n              />\n              <boxBufferGeometry attach=\"geometry\" args={[r, r, r]} />\n            </mesh>\n          </boxHelper>\n        )}\n        {/* Lines connecting particles */}\n        {lines.visible && (\n          <lineSegments\n            geometry={lineMeshGeometry}\n            material={lineMeshMaterial}\n          />\n        )}\n\n        {/* Particles */}\n        {particles.visible && (\n          <points geometry={pointCloudGeometry} material={pointMaterial} />\n        )}\n      </group>\n    </scene>\n  );\n};\n\nParticleField.propTypes = {\n  showCube: PropTypes.bool.isRequired,\n  dimension: PropTypes.oneOf(['2D', '3D']).isRequired,\n  boundaryType: PropTypes.oneOf(['bounce', 'passthru']).isRequired,\n  velocity: PropTypes.number.isRequired,\n  direction: PropTypes.shape({\n    xMin: PropTypes.number,\n    xMax: PropTypes.number,\n    yMin: PropTypes.number,\n    yMax: PropTypes.number,\n    zMin: PropTypes.number,\n    zMax: PropTypes.number\n  }).isRequired,\n  lines: PropTypes.shape({\n    colorMode: PropTypes.oneOf(['rainbow', 'solid']),\n    color: PropTypes.string,\n    transparency: PropTypes.number,\n    maxConnections: PropTypes.number,\n    limitConnections: PropTypes.bool,\n    minDistance: PropTypes.number,\n    visible: PropTypes.bool\n  }).isRequired,\n  particles: PropTypes.shape({\n    count: PropTypes.number,\n    minSize: PropTypes.number,\n    maxSize: PropTypes.number,\n    boundingBox: PropTypes.oneOf(['canvas', 'cube']),\n    shape: PropTypes.oneOf(['circle', 'square']),\n    colorMode: PropTypes.oneOf(['rainbow', 'solid']),\n    color: PropTypes.string,\n    transparency: PropTypes.number,\n    visible: PropTypes.bool\n  }).isRequired,\n  cameraControls: PropTypes.shape({\n    enabled: PropTypes.bool,\n    enableDamping: PropTypes.bool,\n    dampingFactor: PropTypes.number,\n    enableZoom: PropTypes.bool,\n    autoRotate: PropTypes.bool,\n    autoRotateSpeed: PropTypes.number,\n    resetCameraFlag: PropTypes.bool\n  }).isRequired\n};\n\nexport default ParticleField;\n","/**\n * The default configuation for the ParticleField component\n *\n * Any option passed in via props will overwrite the default config\n */\nexport default {\n  showCube: true,\n  dimension: '3D',\n  velocity: 2,\n  boundaryType: 'bounce',\n  antialias: false,\n  direction: {\n    xMin: -1,\n    xMax: 1,\n    yMin: -1,\n    yMax: 1,\n    zMin: -1,\n    zMax: 1\n  },\n  lines: {\n    colorMode: 'rainbow',\n    color: '#351CCB',\n    transparency: 0.9,\n    limitConnections: true,\n    maxConnections: 20,\n    minDistance: 150,\n    visible: true\n  },\n  particles: {\n    colorMode: 'rainbow',\n    color: '#3FB568',\n    transparency: 0.9,\n    shape: 'square',\n    boundingBox: 'canvas',\n    count: 500,\n    minSize: 10,\n    maxSize: 75,\n    visible: true\n  },\n  cameraControls: {\n    enabled: true,\n    enableDamping: true,\n    dampingFactor: 0.2,\n    enableZoom: true,\n    autoRotate: true,\n    autoRotateSpeed: 0.3,\n    resetCameraFlag: false\n  }\n};\n","import React, { useEffect, useState } from 'react';\nimport PropTypes from 'prop-types';\nimport { Canvas } from 'react-three-fiber';\nimport merge from 'lodash.merge';\nimport ParticleField from './ParticleField';\nimport initialConfig from './config';\n\n/**\n * Creates a 2D/3D particle field with react-three-fiber, three.js and WebGL\n *\n * Documentation on the configuration object can be found in the github repo\n * @see https://github.com/tim-soft/react-particles-webgl\n *\n * For a real-time configuration generator and various demos\n * @see https://timellenberger.com/particles\n */\nconst ParticleCanvas = ({ config }) => {\n  const [clientSide, setClientSide] = useState(false);\n  useEffect(() => {\n    setClientSide(true);\n  }, []);\n\n  if (!clientSide) return null;\n\n  return (\n    <Canvas\n      gl={{\n        antialias: Object.prototype.hasOwnProperty.call(config, 'antialias')\n          ? config.antialias\n          : initialConfig.antialias\n      }}\n    >\n      <ParticleField {...merge({}, initialConfig, config)} />\n    </Canvas>\n  );\n};\n\nParticleCanvas.propTypes = {\n  config: PropTypes.object\n};\n\nParticleCanvas.defaultProps = {\n  config: {}\n};\n\nexport default ParticleCanvas;\n\nexport const defaultConfig = { ...initialConfig };\n"]},"metadata":{},"sourceType":"module"}