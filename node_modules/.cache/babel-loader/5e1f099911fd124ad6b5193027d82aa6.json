{"ast":null,"code":"'use strict';\n\nconst hexCharacters = 'a-f\\\\d';\nconst match3or4Hex = `#?[${hexCharacters}]{3}[${hexCharacters}]?`;\nconst match6or8Hex = `#?[${hexCharacters}]{6}([${hexCharacters}]{2})?`;\nconst nonHexChars = new RegExp(`[^#${hexCharacters}]`, 'gi');\nconst validHexSize = new RegExp(`^${match3or4Hex}$|^${match6or8Hex}$`, 'i');\n\nmodule.exports = (hex, options = {}) => {\n  if (typeof hex !== 'string' || nonHexChars.test(hex) || !validHexSize.test(hex)) {\n    throw new TypeError('Expected a valid hex string');\n  }\n\n  hex = hex.replace(/^#/, '');\n  let alpha = 1;\n\n  if (hex.length === 8) {\n    alpha = parseInt(hex.slice(6, 8), 16) / 255;\n    hex = hex.slice(0, 6);\n  }\n\n  if (hex.length === 4) {\n    alpha = parseInt(hex.slice(3, 4).repeat(2), 16) / 255;\n    hex = hex.slice(0, 3);\n  }\n\n  if (hex.length === 3) {\n    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];\n  }\n\n  const num = parseInt(hex, 16);\n  const red = num >> 16;\n  const green = num >> 8 & 255;\n  const blue = num & 255;\n  return options.format === 'array' ? [red, green, blue, alpha] : {\n    red,\n    green,\n    blue,\n    alpha\n  };\n};","map":{"version":3,"sources":["/media/adarsh/New Volume/project/face recognition app/node_modules/hex-rgb/index.js"],"names":["hexCharacters","match3or4Hex","match6or8Hex","nonHexChars","RegExp","validHexSize","module","exports","hex","options","test","TypeError","replace","alpha","length","parseInt","slice","repeat","num","red","green","blue","format"],"mappings":"AAAA;;AAEA,MAAMA,aAAa,GAAG,QAAtB;AACA,MAAMC,YAAY,GAAI,MAAKD,aAAc,QAAOA,aAAc,IAA9D;AACA,MAAME,YAAY,GAAI,MAAKF,aAAc,SAAQA,aAAc,QAA/D;AACA,MAAMG,WAAW,GAAG,IAAIC,MAAJ,CAAY,MAAKJ,aAAc,GAA/B,EAAmC,IAAnC,CAApB;AACA,MAAMK,YAAY,GAAG,IAAID,MAAJ,CAAY,IAAGH,YAAa,MAAKC,YAAa,GAA9C,EAAkD,GAAlD,CAArB;;AAEAI,MAAM,CAACC,OAAP,GAAiB,CAACC,GAAD,EAAMC,OAAO,GAAG,EAAhB,KAAuB;AACvC,MAAI,OAAOD,GAAP,KAAe,QAAf,IAA2BL,WAAW,CAACO,IAAZ,CAAiBF,GAAjB,CAA3B,IAAoD,CAACH,YAAY,CAACK,IAAb,CAAkBF,GAAlB,CAAzD,EAAiF;AAChF,UAAM,IAAIG,SAAJ,CAAc,6BAAd,CAAN;AACA;;AAEDH,EAAAA,GAAG,GAAGA,GAAG,CAACI,OAAJ,CAAY,IAAZ,EAAkB,EAAlB,CAAN;AACA,MAAIC,KAAK,GAAG,CAAZ;;AAEA,MAAIL,GAAG,CAACM,MAAJ,KAAe,CAAnB,EAAsB;AACrBD,IAAAA,KAAK,GAAGE,QAAQ,CAACP,GAAG,CAACQ,KAAJ,CAAU,CAAV,EAAa,CAAb,CAAD,EAAkB,EAAlB,CAAR,GAAgC,GAAxC;AACAR,IAAAA,GAAG,GAAGA,GAAG,CAACQ,KAAJ,CAAU,CAAV,EAAa,CAAb,CAAN;AACA;;AAED,MAAIR,GAAG,CAACM,MAAJ,KAAe,CAAnB,EAAsB;AACrBD,IAAAA,KAAK,GAAGE,QAAQ,CAACP,GAAG,CAACQ,KAAJ,CAAU,CAAV,EAAa,CAAb,EAAgBC,MAAhB,CAAuB,CAAvB,CAAD,EAA4B,EAA5B,CAAR,GAA0C,GAAlD;AACAT,IAAAA,GAAG,GAAGA,GAAG,CAACQ,KAAJ,CAAU,CAAV,EAAa,CAAb,CAAN;AACA;;AAED,MAAIR,GAAG,CAACM,MAAJ,KAAe,CAAnB,EAAsB;AACrBN,IAAAA,GAAG,GAAGA,GAAG,CAAC,CAAD,CAAH,GAASA,GAAG,CAAC,CAAD,CAAZ,GAAkBA,GAAG,CAAC,CAAD,CAArB,GAA2BA,GAAG,CAAC,CAAD,CAA9B,GAAoCA,GAAG,CAAC,CAAD,CAAvC,GAA6CA,GAAG,CAAC,CAAD,CAAtD;AACA;;AAED,QAAMU,GAAG,GAAGH,QAAQ,CAACP,GAAD,EAAM,EAAN,CAApB;AACA,QAAMW,GAAG,GAAGD,GAAG,IAAI,EAAnB;AACA,QAAME,KAAK,GAAIF,GAAG,IAAI,CAAR,GAAa,GAA3B;AACA,QAAMG,IAAI,GAAGH,GAAG,GAAG,GAAnB;AAEA,SAAOT,OAAO,CAACa,MAAR,KAAmB,OAAnB,GACN,CAACH,GAAD,EAAMC,KAAN,EAAaC,IAAb,EAAmBR,KAAnB,CADM,GAEN;AAACM,IAAAA,GAAD;AAAMC,IAAAA,KAAN;AAAaC,IAAAA,IAAb;AAAmBR,IAAAA;AAAnB,GAFD;AAGA,CA9BD","sourcesContent":["'use strict';\n\nconst hexCharacters = 'a-f\\\\d';\nconst match3or4Hex = `#?[${hexCharacters}]{3}[${hexCharacters}]?`;\nconst match6or8Hex = `#?[${hexCharacters}]{6}([${hexCharacters}]{2})?`;\nconst nonHexChars = new RegExp(`[^#${hexCharacters}]`, 'gi');\nconst validHexSize = new RegExp(`^${match3or4Hex}$|^${match6or8Hex}$`, 'i');\n\nmodule.exports = (hex, options = {}) => {\n\tif (typeof hex !== 'string' || nonHexChars.test(hex) || !validHexSize.test(hex)) {\n\t\tthrow new TypeError('Expected a valid hex string');\n\t}\n\n\thex = hex.replace(/^#/, '');\n\tlet alpha = 1;\n\n\tif (hex.length === 8) {\n\t\talpha = parseInt(hex.slice(6, 8), 16) / 255;\n\t\thex = hex.slice(0, 6);\n\t}\n\n\tif (hex.length === 4) {\n\t\talpha = parseInt(hex.slice(3, 4).repeat(2), 16) / 255;\n\t\thex = hex.slice(0, 3);\n\t}\n\n\tif (hex.length === 3) {\n\t\thex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];\n\t}\n\n\tconst num = parseInt(hex, 16);\n\tconst red = num >> 16;\n\tconst green = (num >> 8) & 255;\n\tconst blue = num & 255;\n\n\treturn options.format === 'array' ?\n\t\t[red, green, blue, alpha] :\n\t\t{red, green, blue, alpha};\n};\n"]},"metadata":{},"sourceType":"script"}